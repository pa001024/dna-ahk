AoJia() => AJC
class AJC {
     /**
      * 开启后台
      * @param {Integer} hwnd 要开启后台的窗口的句柄
      * @param {String} screen 决定所有图色和文字函数要在其中查找和识别的图色数据的获取方式,取值只能是下面列出的值之一:
      * 
      * "FD": 表示图色不开启后台,只从窗口Hwnd的客户区所占据的桌面区域获取图色数据 
      * "GDI": 表示图色开启后台 
      * "GDI1": 表示图色开启后台.在这种模式下可以获取整个窗口的图色数据,包括标题栏、菜单和滚动条,而不只是客户区,这时所有图色和文字相关的函数的坐标参数和返回的坐标都相对于窗口左上角(0, 0),窗口右下角的坐标是(窗口宽度 - 1, 窗口高度 - 1).有的窗口没有标题栏、菜单和滚动条,只有客户区,所以窗口大小和客户区大小相等,窗口的坐标也就是客户区的坐标,这时GDI1模式和GDI模式没有分别 
      * "GDI2": 表示图色开启后台.这种模式比GDI模式慢,如果在GDI模式下窗口处于后台不刷新时,可以使用这种模式试一试 
      * "GDI3": 表示图色开启后台,坐标说明和GDI1模式一样,能获取整个窗口的图色数据并且坐标相对于窗口左上角.这种模式比GDI1模式慢,如果在GDI1模式下窗口处于后台不刷新时,可以使用这种模式试一试 
      * "DX": 表示图色开启后台.指定成这个模式需要窗口所在进程是用DirectX10,11,12开发的 
      * "DX9": 表示图色开启后台.指定成这个模式需要窗口所在进程是用DirectX9开发的 
      * "OL": 表示图色开启后台.指定成这个模式需要窗口所在进程是用OpenGL开发的 
      * 图色在开启后台后就只会从参数Hwnd标识的窗口获取图色数据,而不管这个窗口是正在桌面显示还是被遮挡
      * 
      * 在调用这个函数成功后,除了GDI1和GDI3模式,在其它所有图色模式下,所有图色和文字相关的函数的坐标参数和返回的坐标都相对于窗口客户区左上角(0, 0),窗口客户区右下角的坐标是(窗口客户区宽度 - 1, 窗口客户区高度 - 1),也就是坐标的值的有效范围是(0, 0, 窗口客户区宽度 - 1, 窗口客户区高度 - 1).和移动鼠标的函数不一样,对图色和文字函数的坐标参数的值的要求只是传递的左上角横坐标不能大于右下角横坐标,左上角纵坐标不能大于右下角纵坐标.在传递的左上角坐标与右下角坐标关系正确的情况下,如果坐标的值不在有效范围内,函数会将它较正为有效范围的边界值,具体较正方式可看函数SetPCData的说明
      * 
      * 不管窗口所在进程是用什么开发的,大多数窗口都可以用GDI系列模式后台获取图色数据
      * @param {String} keyboard 决定所有键盘按下与弹起的函数是执行前台操作还是后台操作,取值可以是下面列出的值之一:
      * 
      * "FD": 表示键盘不开启后台,所有键盘按下与弹起的函数执行的是前台操作 
      * "WM": 表示键盘开启后台,并使用模拟windows消息的方式,大多数窗口都能通过这种方式模拟后台的键盘操作,如果不能成功可能是窗口句柄不正确造成的,如果使用顶级窗口句柄不能成功,就需要使用真正接收模拟操作的子窗口句柄,可以在此函数成功返回后接着调用函数SetHwndSKM将后台键盘关联到Hwnd所在进程的另一个子窗口 
      * 或者指定成下面列出的值的任意组合,组合用符号"|"进行连接,下面列出的值不能与上面列出的值进行组合:
      * 
      * "DX": 表示键盘开启后台,这个值相当于"KDI|KSI|KLI|KRI" 
      * "KDI": 表示键盘开启后台,并模拟后台的dx键盘操作 
      * "KSI": 表示键盘开启后台,并锁定键盘输入状态 
      * "KLI": 表示键盘开启后台,并锁定键盘输入接口 
      * "KRI": 表示键盘开启后台,有些窗口需要指定这个值才能模拟后台的键盘操作 
      * 键盘在开启后台后只有参数Hwnd标识的窗口能获取函数模拟的键盘操作,而不管这个窗口是正在桌面显示还是被遮挡
      * @param {String} mouse 决定所有鼠标按下与弹起以及移动的函数是执行前台操作还是后台操作,取值可以是下面列出的值之一:
      * 
      * "FD": 表示鼠标不开启后台,所有鼠标按下与弹起以及移动的函数执行的是前台操作 
      * "WM": 表示鼠标开启后台,并使用模拟windows消息的方式,大多数窗口都能通过这种方式模拟后台的鼠标操作,如果不能成功可能是窗口句柄不正确造成的,如果使用顶级窗口句柄不能成功,就需要使用真正接收模拟操作的子窗口句柄,可以在此函数成功返回后接着调用函数SetHwndSKM将后台鼠标关联到Hwnd所在进程的另一个子窗口 
      * 或者指定成下面列出的值的任意组合,组合用符号"|"进行连接,下面列出的值不能与上面列出的值进行组合:
      * 
      * "DX": 表示鼠标开启后台,这个值相当于"MDI|MSIA|MSIM|MLI|MRI|MLPA|MLPM|MLQ|MCR" 
      * "MDI": 表示鼠标开启后台,并模拟后台的dx鼠标操作 
      * "MSIA": 表示鼠标开启后台,并通过封锁API来锁定鼠标输入状态 
      * "MSIM": 表示鼠标开启后台,并通过封锁消息来锁定鼠标输入状态 
      * "MLI": 表示鼠标开启后台,并锁定鼠标输入接口 
      * "MRI": 表示鼠标开启后台,有些窗口需要指定这个值才能模拟后台的鼠标操作 
      * "MLPA": 表示鼠标开启后台,并通过封锁API来锁定鼠标位置 
      * "MLPM": 表示鼠标开启后台,并通过封锁消息来锁定鼠标位置 
      * "MLQ": 表示鼠标开启后台,并防止在移动后台鼠标时导致前台鼠标移动 
      * "MCR": 表示鼠标开启后台,只有指定了这个值才能获取后台鼠标特征码 
      * 鼠标在开启后台后只有参数Hwnd标识的窗口能获取函数模拟的鼠标操作,而不管这个窗口是正在桌面显示还是被遮挡
      * 
      * 在调用这个函数成功后,所有移动鼠标的函数的坐标参数都相对于窗口客户区左上角(0, 0),窗口客户区右下角的坐标是(窗口客户区宽度 - 1, 窗口客户区高度 - 1),也就是坐标的值的有效范围是(0, 0, 窗口客户区宽度 - 1, 窗口客户区高度 - 1),如果坐标的值不在这个范围内,那么移动鼠标的函数会执行失败
      * @param {String} flag 这个值可以为空,也可以是下面列出的值之一或它们的任意组合,组合用符号"|"进行连接:
      * "LAA": 表示通过封锁API来锁定窗口激活状态 
      * "LAM": 表示通过封锁消息来锁定窗口激活状态 
      * "LFA": 表示通过封锁API来锁定窗口输入焦点 
      * "LFM": 表示通过封锁消息来锁定窗口输入焦点 
      * "LR": 表示锁定窗口刷新区域为整个客户区 
      * "LP": 表示禁止手动移动窗口位置 
      * "LS": 表示禁止手动改变窗口大小 
      * "LM": 表示禁止手动最大化或最小化窗口 
      * "DC": 只有指定了这个值,接下来才能调用函数DownCpu并将参数DCpuD设为1以降低目标窗口所在进程的CPU占用率 
      * "LK": 表示使用更快的OpenGL后台图色模式,只有参数Screen的值为"OL"时指定这个值才有效 
      * "FD": 表示程序在运行过程中如果窗口被最小化或被遮挡则激活窗口,只有参数Screen或Mouse的值为"FD"时指定这个值才有效 
      * @param {Integer} type 向窗口所在进程注入Dll的方式,只能是下面列出的值之一:
      * 方式0 
      * 1: 方式1 
      * 2: 方式2 
      * 3: 方式3 
      * 4: 方式4 
      * 5: 方式5 
      * 只有满足下面列出的条件之一时函数才会向窗口所在进程注入Dll:
      * 
      * 参数Screen包含右边这些值中的任何1个: DX, DX9, OL 
      * 参数Keyboard包含右边这些值中的任何1个: DX, KDI, KSI, KLI, KRI 
      * 参数Mouse包含右边这些值中的任何1个: DX, MDI, MSIA, MSIM, MLI, MRI, MLPA, MLPM, MLQ, MCR 
      * 参数Flag包含右边这些值中的任何1个: LAA, LAM, LFA, LFM, LR, DC 
      * 如果有的进程用某种方式不能注入成功,可以尝试使用其它方式.不管哪种方式都对后台功能没有影响,使用不同的方式后台功能都是一样的
      * 
      * 在进行注入时插件会释放AzrJ32.exe, AhkJ32.dll或者AzrJ64.exe, AhkJ64.dll这些文件到插件所在的文件夹中,然后会运行AzrJ32.exe/AzrJ64.exe并把AhkJ32.dll/AhkJ64.dll注入到窗口所在进程中,在后台关闭后AzrJ32.exe/AzrJ64.exe生成的进程会自动关闭,如果后台未能成功的开启和关闭,那么AzrJ32.exe/AzrJ64.exe生成的进程可能会无法正常关闭,这时可以用任务管理器强制结束
      * 
      * 对于部分有保护的进程,这个函数会注入失败
      * @returns {Integer} 返回1表示成功,0表示失败
      */
     KQHouTai(hwnd, screen, keyboard, mouse, flag, type) => Integer
     GBHouTai() => Integer
     MoveR(rx, ry) => Integer
     MiddleClick() => Integer
     /**
      * 阻止键盘和鼠标的输入
      * @param Type 整数,取值只能是0或1,0表示解除阻止,1表示进行阻止,只有进行阻止输入的线程才能成功地解除阻止输入
      * @returns {Integer} 返回1表示成功,0表示失败
      */
     BlockInput(Type) => Integer
     /**
      * 获取鼠标的双击时间,也就是第一次单击和第二次单击之间允许的最大毫秒数
      * @returns {Integer} 返回鼠标的双击时间,单位是毫秒
      */
     GetDoubleClickTime() => Integer
     /**
      * 获取前台指定的按键状态,包括鼠标的左右中键
      * @param KeyD 按键对应的虚拟键码,其有效值范围是大于等于1且小于等于254的整数,各按键所对应的虚拟键码可通过插件工具查看.传递1可查看鼠标左键是否被按下,2是鼠标右键,4是鼠标中键.
      * @returns {Integer} 返回1表示按下,0表示没按下,参数错误返回-1
      */
     GetKeyDState(KeyD) => Integer
     /**
      * 获取鼠标热点的坐标
      * @param x 返回鼠标热点的横坐标,失败返回-1
      * @param y 返回鼠标热点的纵坐标,失败返回-1
      * @param Type 只能取下面列出的值之一:
      * 0: 无论有没有开启后台都只返回前台鼠标热点的坐标 
      * 1: 如果没有开启后台则返回前台鼠标热点的坐标,如果开启了后台则返回后台鼠标热点的坐标,要获取后台鼠标热点的坐标需要在开启后台时给函数KQHouTai的参数Mouse指定"MCR"这个值
      * @returns {Integer} 
      */
     GetMouseHotspot(&x, &y, Type) => Integer
     /**
      * 获取当前鼠标坐标
      * @param x 返回获取到的鼠标横坐标,失败返回-1
      * @param y 返回获取到的鼠标纵坐标,失败返回-1
      * @param Type 整数,只能是下面列出的值之一:
      * 0: 表示忽略函数KQHouTai与SetDesktopArea的设置,只返回前台真实的鼠标坐标 
      * 1: 如果没有开启后台也没有调用函数SetDesktopArea设置过,那么返回的是前台真实的鼠标坐标,如果已经调用过函数SetDesktopArea并且设置成功,那么返回的是由函数SetDesktopArea决定的鼠标坐标,如果开启了后台则返回后台鼠标的坐标,后台鼠标不是真实的鼠标,返回的实际上是后台模式时所有移动鼠标的函数最后一次设置的后台鼠标位置
      * @returns {Integer} 返回1表示成功,0表示失败
      */
     GetMousePos(&x, &y, Type) => Integer
     /**
      * 获取鼠标特征码
      * @param Type 决定返回的是前台鼠标特征码还是后台鼠标特征码,只能是下面列出的值之一:
      * 0: 无论有没有开启后台都只返回前台鼠标特征码 
      * 1: 如果没有开启后台则返回前台鼠标特征码,如果开启了后台则返回后台鼠标特征码,要获取后台鼠标特征码需要在开启后台时给函数KQHouTai的参数Mouse指定"MCR"这个值
      * @param Flag 整数,只能是下面列出的值之一:
      * 0: 方式0 
      * 1: 方式1 
      * @returns {String} 返回获取到的鼠标特征码,失败返回空
      */
     GetMouseShape(Type, Flag) => String
     /**
      * 获取鼠标的移动速度
      * @returns {Integer} 返回获取到的鼠标移动速度,值的范围大于等于1且小于等于20
      */
     GetMouseSpeed() => Integer
     /**
      * 按住指定的按键
      * @param {Integer} KeyD 按键对应的虚拟键码,其有效值范围是大于等于1小于等于254的整数,各按键所对应的虚拟键码可通过插件工具查看
      * @returns {Integer} 返回1表示成功,0表示失败
      */
     KeyDown(KeyD) => Integer
     /**
      * 按住指定的按键
      * @param {String} KeyDS 只能是KeyDS与KeyD的对应表列出的值中的某一个,和键盘上各按键标注的字符一致
      * @returns {Integer} 
      */
     KeyDownS(KeyDS) => Integer

     /**
      * 按下指定的按键
      * @param KeyD 按键对应的虚拟键码,其有效值范围是大于等于1且小于等于254的整数,各按键所对应的虚拟键码可通过插件工具查看
      * @returns {Integer} 
      */
     KeyPress(KeyD) => Integer

     /**
      * 按下指定的按键,可设置按键过程中按下和弹起之间的随机延时范围,以及按键完成后的随机延时范围,延时时间单位为毫秒
      * @param KeyD 按键对应的虚拟键码,其有效值范围是大于等于1小于等于254的整数,各按键所对应的虚拟键码可通过插件工具查看
      * @param RMin 按键按下和弹起之间随机延时范围的最小值,RMin应该大于0且小于等于RMax,为模拟人手,RMin最小不要小于50毫秒
      * @param RMax 按键按下和弹起之间随机延时范围的最大值,RMax应该大于0且大于等于RMin
      * @param RDMin 按键弹起也就是按键完成后随机延时范围的最小值,RDMin应该大于等于0且小于等于RDMax
      * @param RDMax 按键弹起也就是按键完成后随机延时范围的最大值,RDMax应该大于等于0且大于等于RDMin
      * @returns {Integer} 
      */
     KeyPressD(KeyD, RMin, RMax, RDMin, RDMax) => Integer

     /**
      * 按下指定的按键
      * @param {String} KeyDS 只能是KeyDS与KeyD的对应表列出的值中的某一个,和键盘上各按键标注的字符一致.点击这里查看KeyDS与KeyD的对应表
      * @returns {Integer} 
      */
     KeyPressS(KeyDS) => Integer

}